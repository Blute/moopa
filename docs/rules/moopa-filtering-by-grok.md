# Filtering in Moopa Framework (Generated by Grok)

This document explains how filtering is typically implemented in the Moopa framework, based on analysis of route CFCs (e.g., in purchasing, drawings, etc.). Filtering allows dynamic querying of data in load endpoints, often combined with search functionality.

## Overview
- **Backend**: Filters are processed in route endpoints (e.g., `load` or `load_with_filters`) using `request.data.filters` struct.
- **Frontend**: UI components (Alpine.js) maintain a `filters` object, often persisted with `Alpine.$persist()`, and send it in `req()` body.
- **Integration**: Filters build dynamic WHERE clauses in SQL queries for precise data retrieval.

## Backend Implementation (in Route CFCs)
Filtering is handled in endpoints that load data lists. Common pattern:

1. **Parametrize Filters**:
   ```cfml
   <cfparam name="request.data.filters" default={} />
   ```

2. **Build WHERE Conditions**:
   - Check for specific filter keys in `request.data.filters`.
   - Add conditions to the query.
   - Handles various types: IDs (often as structs with `id`), dates, strings, statuses.

   Example from purchasing\index.cfc:
   ```cfml
   <cfif len(request.data.filters.company_id.id?:'')>
       AND purchase.company_id = <cfqueryparam cfsqltype="other" value="#request.data.filters.company_id.id#" />
   </cfif>
   <cfif len(request.data.filters.filter_date?:'')>
       <cfif ArrayLen(request.data.filters.filter_date) EQ 1>
           AND DATE(purchase.date AT TIME ZONE ...) = <cfqueryparam ... />
       <cfelseif ArrayLen(request.data.filters.filter_date) EQ 2>
           AND DATE(purchase.date AT TIME ZONE ...) BETWEEN <cfqueryparam ... /> AND <cfqueryparam ... />
       </cfif>
   </cfif>
   <cfswitch expression="#request.data.filters.filter_paid?:''#">
       <cfcase value="Paid">
           AND purchase.paid = true
       </cfcase>
       <!-- Other cases -->
   </cfswitch>
   ```

3. **Integration with Search**:
   - Often combined with `q` for text search.
   - Uses Meilisearch for efficient ID retrieval: `search_ids = application.lib.meilisearch.search_index(...)`
   - Then: `AND id IN (<cfqueryparam list="true" value="#search_ids#" />)`

4. **db.cfc Usage**:
   - Simpler filters use `application.lib.db.search(where=where_conditions)`.
   - Complex ones build custom queries with helpers like `select()` and `orderby()`.

## Frontend Implementation (Alpine.js via app.js)
Filtering UI uses reactive components:

1. **Component Setup**:
   ```javascript
   // Define default filters outside the component
   const DEFAULT_FILTERS = () => ({
       company_id: {},
       site_id: {},
       contract_number: '',
       integrity_check: "all",
       only_remaining_commitments: false
   });

   Alpine.data('filterComponent', () => ({
       records: [],
       loading: false,
       filters: Alpine.$persist(DEFAULT_FILTERS()).as('my-filters').using(sessionStorage),
       init() {
           this.handleLoad();
           this.setupFilterListeners();
       },
       setupFilterListeners() {
           this.$el.addEventListener('moo:updated', (event) => {
               if (event.detail.path.startsWith('filters.')) {
                   this.handleLoad();
               }
           });
       },
       async handleLoad() {
           this.loading = true;
           try {
               this.records = await req({
                   endpoint: 'load',
                   body: { filters: this.filters }
               });
           } finally {
               this.loading = false;
           }
       },
       handleResetFilter() {
           this.filters = DEFAULT_FILTERS();
           this.handleLoad();
       }
   }));
   ```

2. **UI Controls**:
   - Use `<cf_control>` tags for inputs (e.g., combobox for company_id).
   - Bind to `filters.company_id`, etc.
   - Changes trigger `moo:updated` event, which reloads data.

3. **Sending Filters**:
   - `req()` includes `body: { filters: this.filters }`, becoming `request.data.filters` on backend.

## Common Patterns
- **Date Ranges**: Handled as arrays in filters (single date or range).
- **Statuses/Enums**: Use switch for multiple conditions.
- **IDs as Structs**: Filters like `company_id: {id: 'uuid'}` for combobox selections.
- **Ordering**: Often `request.data.filters.order_by` for dynamic ORDER BY.
- **Persistence**: Filters persist across sessions via Alpine persist.
- **Reset**: Clear filters and reload.

This setup enables flexible, reactive filtering with minimal code.
