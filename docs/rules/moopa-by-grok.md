# Moopa Framework Guide (Generated by Grok)

This document provides a detailed explanation of the Moopa framework, focusing on routes, endpoints, API calls via `req()` in app.js, and CRUD operations handled by db.cfc. It is based on analysis of the framework's code, including application.cfc, route.cfm, db.cfc, app.js, and the routes structure. This guide is intended for use with Cursor AI to understand and work with the framework.

## Overview
Moopa is a full-stack web framework built on Lucee CFML (ColdFusion Markup Language) with PostgreSQL as the database backend. It emphasizes file-based routing, where routes are defined as CFC (ColdFusion Component) files in the `routes/` directory. The framework handles both page rendering and API endpoints seamlessly.

Key components:
- **Backend**: Lucee CFML, PostgreSQL
- **Frontend Integration**: Works with Alpine.js and TailwindCSS via app.js
- **Routing**: File-based, with automatic slug parameter handling
- **Data Handling**: request.data for POST bodies, automatic CRUD via db.cfc
- **API Calls**: Handled by `req()` function in app.js

## Routes and Endpoints

### File-Based Routing
Routes in Moopa are defined by CFC files in `code/project/routes/`. The file structure maps directly to URL paths:
- `/supplier_statements/` → `routes/supplier_statements/index.cfc` or `routes/supplier_statements.cfc`
- `/purchasing/[purchase_id]/` → `routes/purchasing/[purchase_id]/index.cfc`
- Slugs like `[purchase_id]` become dynamic parameters, automatically available as `arguments.purchase_id` in the CFC endpoint methods.

Each CFC can contain multiple functions (endpoints):
- **get**: Typically renders the page (HTML output).
- **load**: GET endpoint for fetching data.
- **save**: POST endpoint for saving data.
- **search.filters.company_id**: Nested endpoints using dot notation for specific actions like searches.

Example CFC structure (from guide):
```cfml
<cfcomponent key="unique-key">
    <cffunction name="load">
        <!-- GET data -->
    </cffunction>
    <cffunction name="save">
        <!-- POST save -->
    </cffunction>
    <cffunction name="get" output="true">
        <cf_layout_default>
            <!-- HTML with Alpine.js -->
        </cf_layout_default>
    </cffunction>
</cfcomponent>
```

### How Routes Are Processed
- **application.cfc**: The entry point. In `OnRequest`, it checks if the target is `/_moopa.cfm` (via nginx rewrite) and calls `_moopa()`.
- **_moopa()**: Parses the request, sets `request.data` from form or JSON body, determines the endpoint (from headers, URL, or method), and invokes `<cf_route>`.
- **route.cfm**: A custom tag that:
  - Parses the route using `moo_route.parseRoute()`.
  - Checks access permissions.
  - Instantiates the route CFC and invokes the specified endpoint.
  - Handles output or returns content.

- **Dynamic Parameters**: Slugs in URLs (e.g., `/purchasing/[purchase_id]/`) are automatically passed as arguments to the endpoint function (e.g., `arguments.purchase_id`).
- **request.data**: For POST requests, the body is available here. app.js's `req()` sends data as JSON, which is deserialized into `request.data`.

app.js's `req()` auto-detects HTTP methods:
- No body: GET
- With body: POST

**Note**: The HTTP method is generally not required to be explicitly specified as it is automatically derived from the presence or absence of a request body. This simplifies API calls and reduces boilerplate code.

### Security and Access
- Routes/endpoints specify `open_to` (e.g., 'public', 'validated', 'security').
- Checked via `moo_route.checkAccess()`. Unauthenticated users are redirected to login.

## API Calls with req() in app.js
The `req()` function in `www/_static/js/app.js` is the primary way to call backend endpoints from the frontend (e.g., Alpine.js components).

### Basic Usage
```javascript
// GET
const data = await req({ endpoint: 'load' });

// POST
const result = await req({
    endpoint: 'save',
    body: { name: 'John' }  // Becomes request.data on backend
});

// Search
const results = await req({
    endpoint: 'search.filters.company_id',
    q: 'search term'  // Becomes url.q
});
```

### Key Features
- **Endpoint**: Maps to CFC function (e.g., 'load' calls `load()`).
- **Body**: Sent as JSON, available as `request.data` in CFC.
- **URL Params**: Added to query string (e.g., `q`, `id`).
- **Method Detection**: Auto-POST if body present, else GET.
- **Error Handling**: Catches 401 (redirects to login), shows notifications.
- **File Uploads**: Use FormData for POST.

req() constructs the URL from current path or specified route, adds params, and fetches. Responses are JSON or text.

## CRUD Operations with db.cfc
db.cfc provides abstracted CRUD via PostgreSQL helpers. It's initialized in application.cfc and used in route CFCs.

### Core Functions
- **search(table_name, where={}, q='', ids=[], limit=250)**: Returns array of records. Supports text search, filters, IDs.
- **read(table_name, id)**: Returns single record as JSON/CFML struct.
- **save(table_name, data)**: Upserts (insert if no ID, update if ID present). Handles many-to-many.
- **delete(table_name, id)**: Deletes record.
- **getNewObject(table_name, data={}, create=false)**: Returns template object with defaults.

### Usage in Routes
Endpoints use these for data ops:
```cfml
<cffunction name="load">
    <cfreturn application.lib.db.search(table_name="my_table", where={active: true}) />
</cffunction>

<cffunction name="save">
    <cfreturn application.lib.db.save(table_name="my_table", data=request.data) />
</cffunction>
```

- **Schema Management**: db.cfc syncs code-defined schemas (in /tables/*.cfc) with DB, generating SQL for alters/creations.
- **Automatic Features**: Handles defaults, generated columns, relations, many-to-many bridges.

## Integration Flow
1. **Frontend Call**: Alpine.js uses `req({endpoint: 'save', body: data})`.
2. **app.js**: Builds URL, sends fetch, handles response.
3. **Backend**: application.cfc → _moopa() → route.cfm invokes CFC endpoint.
4. **Endpoint**: Uses `request.data`, calls db.cfc CRUD, returns JSON.
5. **Response**: Sent back to frontend.

Arguments from URL slugs are auto-injected (e.g., `arguments.purchase_id`).

This framework enables rapid development with file-based routes, reactive frontend, and abstracted DB ops.
