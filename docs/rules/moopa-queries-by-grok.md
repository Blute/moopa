# Dynamic Queries in Moopa Framework (Generated by Grok)

This document explains how dynamic queries are built in Moopa routes using db.cfc's `select()` helper, inline WHERE conditions, joins, and subqueries. Based on analysis of routes/ directory.

## Overview
- **db.select()**: Generates SQL field lists (e.g., `id, name`) for SELECT statements, with options for simple/expanded/condensed modes.
- **Dynamic Queries**: Built with `<cfquery>`, using `cfparam` for `request.data.filters`, conditional `<cfif>` for WHERE clauses.
- **Common Patterns**: Parametrized inputs with `<cfqueryparam>`, joins for relations, subqueries for aggregates.

## Basic Usage of db.select()
```cfml
SELECT #application.lib.db.select(table_name="my_table", field_list="id,name")#
FROM my_table
WHERE active = true
```

- **Modes**: `simple` (basic fields), `expanded` (with joins/JSON builds), `condensed` (minimal like id,label).

## Dynamic WHERE Conditions
Inline conditions based on `request.data.filters` or params:
```cfml
<cfparam name="request.data.filters" default={} />

<cfquery name="q">
    SELECT ...
    FROM my_table
    WHERE 1=1
    <cfif len(request.data.filters.status)>
        AND status = <cfqueryparam value="#request.data.filters.status#" cfsqltype="varchar" />
    </cfif>
    <cfif len(request.data.filters.date_from) AND len(request.data.filters.date_to)>
        AND date BETWEEN <cfqueryparam value="#request.data.filters.date_from#" cfsqltype="date" />
                    AND <cfqueryparam value="#request.data.filters.date_to#" cfsqltype="date" />
    </cfif>
</cfquery>
```

## Complex Examples

### Example 1: Joins and Filters (from purchasing\[purchase_id]\edit_v3.cfc)
Dynamic load with joins for documents, filters on dates/sites/companies:
```cfml
<cfquery name="q">
    SELECT COALESCE(jsonb_agg(data)::text, '[]') as data
    FROM (
        SELECT #application.lib.db.select(table_name="document", field_list="id,name,site_id,company_id,cost_code_id,doc_status,doc_type,doc_date,doc_number,total_amount,description")#
        FROM document
        <cfif ArrayLen(request.data.filters.filter_date) EQ 1>
            AND DATE(document.doc_date AT TIME ZONE ...) = <cfqueryparam ... />
        <cfelseif ArrayLen(request.data.filters.filter_date) EQ 2>
            AND DATE(document.doc_date AT TIME ZONE ...) BETWEEN <cfqueryparam ... /> AND <cfqueryparam ... />
        </cfif>
        <cfif len(request.data.filters.site_id.id?:'')>
            AND document.site_id = <cfqueryparam ... />
        </cfif>
        <!-- More filters -->
        ORDER BY doc_date DESC
    ) as data
</cfquery>
```
- **Dynamic**: WHERE built from filters.
- **Aggregation**: jsonb_agg for JSON array output.

### Example 2: Subqueries and Joins (from site\[site_id]\budget_v4.cfc)
Budget calculation with multiple joins and subqueries:
```cfml
<cfquery name="q">
    SELECT #application.lib.db.select(table_name="purchase", field_list="id,type,ref,date,company_id,supplier_reference")#,
           company.label as company_name,
           -- Subquery for lines
           (SELECT jsonb_agg(pl.*) FROM (
               SELECT #application.lib.db.select(table_name="purchase_line", field_list="*")#
               FROM purchase_line
               WHERE purchase_line.purchase_id = purchase.id
           ) pl) as lines
    FROM purchase
    LEFT JOIN company ON purchase.company_id = company.id
    WHERE purchase.site_id = <cfqueryparam ... />
    <!-- Inline filters from request.data.filters -->
    <cfif len(request.data.filters.company_id)>
        AND purchase.company_id = <cfqueryparam ... />
    </cfif>
    -- More conditions
</cfquery>
```
- **Joins**: LEFT JOIN for company details.
- **Subquery**: Nested SELECT for purchase lines, aggregated as JSON.

### Example 3: Complex Subqueries (from _import/subcontracts.cfc)
Import processing with WITH clause and subqueries:
```cfml
<cfquery name="q">
    WITH filtered AS (
        SELECT #application.lib.db.select(table_name="imported_subcontract")#
        , (
            SELECT jsonb_agg(data)::jsonb as data
            FROM (
                SELECT #application.lib.db.select(table_name="imported_subcontract_invoice")#
                FROM imported_subcontract_invoice
                WHERE imported_subcontract_id = imported_subcontract.id
                ORDER BY raw_data->>'invoice_date'
            ) as data
        ) as invoices
        FROM imported_subcontract
        WHERE 1=1
        <cfif len(request.data.filters.contract_number)>
            AND raw_data->>'subcontract_number' = <cfqueryparam ... />
        </cfif>
        <!-- More dynamic filters -->
    )
    SELECT COALESCE(jsonb_agg(data)::text, '[]') AS data,
           (SELECT COUNT(*) FROM filtered) AS total_records
    FROM (SELECT * FROM filtered ORDER BY raw_data->>'contract_date' DESC LIMIT 100) AS data
</cfquery>
```
- **WITH Clause**: For filtered data with subquery for invoices.
- **Dynamic WHERE**: Based on filters like contract_number, site_id.
- **Aggregation and Paging**: jsonb_agg with LIMIT for performance.

## Best Practices
- Use `<cfqueryparam>` for all variables to prevent SQL injection.
- Build WHERE with `1=1` base for easy conditional appending.
- Leverage db.select() for consistent field lists.
- For complexity, use subqueries for nested data, joins for relations.
- Combine with filters for user-driven queries.

This pattern allows flexible, secure dynamic querying in Moopa.
